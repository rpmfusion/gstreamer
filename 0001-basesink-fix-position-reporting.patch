From 9da89ef4e1aa6ed11d0bcf335fc9f2b9fadb28e9 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wim.taymans@collabora.co.uk>
Date: Mon, 16 Nov 2009 14:02:07 +0100
Subject: [PATCH 01/47] basesink: fix position reporting

Only update the current stream time after we checked if we got a new step
event. This improves the position reporting by the sink.

See #595958
---
 libs/gst/base/gstbasesink.c |   15 ++++++++-------
 1 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/libs/gst/base/gstbasesink.c b/libs/gst/base/gstbasesink.c
index 7bc76a3..d695be7 100644
--- a/libs/gst/base/gstbasesink.c
+++ b/libs/gst/base/gstbasesink.c
@@ -1854,6 +1854,7 @@ do_times:
                 &rstart, &rstop))) {
       /* step is still busy, we discard data when we are flushing */
       *stepped = step->flush;
+      GST_DEBUG_OBJECT (basesink, "stepping busy");
     }
   }
   /* this can produce wrong values if we accumulated non-TIME segments. If this happens,
@@ -2254,13 +2255,6 @@ again:
   if (G_UNLIKELY (ret != GST_FLOW_OK))
     goto preroll_failed;
 
-  /* After rendering we store the position of the last buffer so that we can use
-   * it to report the position. We need to take the lock here. */
-  GST_OBJECT_LOCK (basesink);
-  priv->current_sstart = sstart;
-  priv->current_sstop = (GST_CLOCK_TIME_IS_VALID (sstop) ? sstop : sstart);
-  GST_OBJECT_UNLOCK (basesink);
-
   /* update the segment with a pending step if the current one is invalid and we
    * have a new pending one. We only accept new step updates after a preroll */
   if (G_UNLIKELY (pending->valid && !current->valid)) {
@@ -2268,6 +2262,13 @@ again:
     goto do_step;
   }
 
+  /* After rendering we store the position of the last buffer so that we can use
+   * it to report the position. We need to take the lock here. */
+  GST_OBJECT_LOCK (basesink);
+  priv->current_sstart = sstart;
+  priv->current_sstop = (GST_CLOCK_TIME_IS_VALID (sstop) ? sstop : sstart);
+  GST_OBJECT_UNLOCK (basesink);
+
   if (!do_sync)
     goto done;
 
-- 
1.6.5.2

